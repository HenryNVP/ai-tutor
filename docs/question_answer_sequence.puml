@startuml
title Question Answering Flow (Multi-Agent Orchestration)

actor User
participant CLI as "CLI / Web UI"
participant TutorSystem
participant Orchestrator as "Orchestrator Agent\n(Router)"
participant Session as "SQLite Session\n(daily rotation)"
participant QAAgent as "QA Agent"
participant Retriever
participant VectorStore
participant WebAgent as "Web Agent"
participant SearchTool
participant OpenAI as "OpenAI API\n(gpt-4o-mini)"

User -> CLI : Ask question\n"What is Bernoulli equation?"
CLI -> TutorSystem : answer_question(\nlearner_id, question)
TutorSystem -> Orchestrator : _answer_async(\nlearner_id, question)

Orchestrator -> Session : Get or create session\nai_tutor_{learner_id}_{YYYYMMDD}
note right of Session
  Sessions auto-rotate daily
  to prevent token overflow
end note
Session --> Orchestrator : SQLiteSession

Orchestrator -> Orchestrator : Build minimal prompt:\n• Profile summary\n• Question only
Orchestrator -> OpenAI : Send to orchestrator agent

OpenAI -> Orchestrator : Route decision
note left of OpenAI
  Orchestrator is pure router:
  - STEM question → qa_agent
  - Current events → web_agent
  - Upload → ingestion_agent
  - Quiz → generate_quiz tool
end note

alt STEM Question (Math/Physics/CS/etc)
  Orchestrator -> QAAgent : Handoff to qa_agent
  QAAgent -> QAAgent : Check instructions:\n"ALWAYS call retrieve_local_context"
  QAAgent -> Retriever : retrieve_local_context(query)
  Retriever -> VectorStore : Search for chunks
  VectorStore --> Retriever : Top 5 chunks with scores
  Retriever --> QAAgent : Context + citations
  
  alt Context found
    QAAgent -> OpenAI : Generate answer with\nlocal citations [1][2]
    OpenAI --> QAAgent : Cited answer
    QAAgent --> Orchestrator : Answer with sources
  else No useful context
    QAAgent -> WebAgent : Handoff to web_agent
    WebAgent -> SearchTool : web_search(query)
    SearchTool --> WebAgent : Web results + URLs
    WebAgent -> OpenAI : Synthesize answer
    OpenAI --> WebAgent : Answer with URL citations
    WebAgent --> Orchestrator : Web-based answer
  end

else Current Event / Non-STEM
  Orchestrator -> WebAgent : Handoff to web_agent
  WebAgent -> SearchTool : web_search(query)
  SearchTool --> WebAgent : Web results
  WebAgent -> OpenAI : Synthesize answer
  OpenAI --> WebAgent : Answer with URLs
  WebAgent --> Orchestrator : Web answer

else Quiz Request
  Orchestrator -> Orchestrator : Call generate_quiz tool
  note right
    See quiz sequence diagram
    for full quiz flow
  end note
  Orchestrator --> User : Quiz questions

end

Orchestrator -> Session : Save conversation turn
Orchestrator --> TutorSystem : TutorResponse(\nanswer, citations)
TutorSystem --> CLI : Response object
CLI --> User : Display answer\n+ citations

note right of QAAgent
  QA Agent MUST:
  1. Always call retrieve_local_context first
  2. Include citations [1][2] in answer
  3. List all sources at end
  4. Hand off to web_agent if no context
end note

note right of WebAgent
  Web Agent MUST:
  1. Always call web_search first
  2. Include URL citations
  3. List all sources at end
end note

note left of Orchestrator
  Token Management:
  • Date-based session IDs
  • Auto-rotate daily
  • Manual clear via scripts/clear_sessions.py
  • Uses gpt-4o-mini (200K TPM limit)
end note

@enduml

@startuml
title Quiz Flow with Profile Updates

actor Learner
participant QuizUI as "Quiz UI\n(Streamlit)"
participant TutorSystem
participant QuizService
participant Retriever
participant OpenAI as "OpenAI API"
participant ProgressTracker
participant Profile as "LearnerProfile\n*.json"

Learner -> QuizUI : Request quiz\n(topic="Newton's Laws", count=4)
QuizUI -> TutorSystem : generate_quiz(\nlearner_id, topic, count)
TutorSystem -> QuizService : generate_quiz(...)

QuizService -> Retriever : Find relevant chunks\nfor topic
Retriever --> QuizService : Context chunks
QuizService -> OpenAI : Generate multiple-choice\nquestions with distractors
OpenAI --> QuizService : Quiz questions
QuizService --> TutorSystem : Quiz object
TutorSystem --> QuizUI : Quiz questions
QuizUI --> Learner : Display quiz

Learner -> QuizUI : Submit answers\n[0, 2, 1, 3]
QuizUI -> TutorSystem : evaluate_quiz(\nlearner_id, quiz, answers)
TutorSystem -> QuizService : evaluate_quiz(...)

QuizService -> QuizService : Grade each answer
QuizService -> QuizService : Calculate score\n(3/4 = 75%)

QuizService -> ProgressTracker : load_profile(learner_id)
ProgressTracker -> Profile : Read JSON
Profile --> ProgressTracker : Current profile

QuizService -> QuizService : _update_profile_from_quiz(\nprofile, quiz, evaluation)
note right
  Score = 75% (≥70%):
  • domain_strengths["newton's laws"] += 0.12
  • domain_struggles["newton's laws"] -= 0.08
  • difficulty_preferences["newton's laws"] = "independent challenge"
  • concepts_mastered["newton's laws"] += 3
  • total_time_minutes += 6.0 (4 questions × 1.5)
end note

QuizService -> ProgressTracker : save_profile(profile)
ProgressTracker -> Profile : Write updated JSON
Profile --> ProgressTracker : Saved

QuizService --> TutorSystem : QuizEvaluation(\nscore=0.75, correct=3/4)
TutorSystem --> QuizUI : Evaluation results
QuizUI --> Learner : Display:\n• Score: 75%\n• Correct: 3/4\n• Updated profile shown in sidebar

note right of Profile
  Profile tracks per-domain:
  • strengths (0.0-1.0)
  • struggles (0.0-1.0)
  • concepts_mastered (count)
  • difficulty_preferences
  • total_time_minutes
end note

@enduml
